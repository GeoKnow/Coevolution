package com.unister.semweb.geoknow.coevolution.resource;

import java.text.ParseException;
import java.util.Date;
import java.util.Set;

import org.apache.commons.lang.SerializationException;
import org.apache.commons.lang.StringUtils;
import org.openrdf.model.Model;
import org.openrdf.model.Resource;
import org.openrdf.model.URI;
import org.openrdf.model.Value;
import org.openrdf.model.impl.LinkedHashModel;
import org.openrdf.model.impl.LiteralImpl;
import org.openrdf.model.impl.URIImpl;
import org.openrdf.model.vocabulary.DCTERMS;
import org.openrdf.model.vocabulary.RDF;
import org.openrdf.model.vocabulary.RDFS;
import org.openrdf.model.vocabulary.XMLSchema;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.unister.semweb.geoknow.coevolution.rdf.Namespace;
import com.unister.semweb.geoknow.coevolution.rdf.RdfConvertible;
import com.unister.semweb.geoknow.coevolution.rdf.RdfUtils;
import com.wordnik.swagger.annotations.ApiModel;
import com.wordnik.swagger.annotations.ApiModelProperty;

/**
 * A collection or class of graphs, with a certain identifier and simple properties. The identifier is relative to
 * {@link Namespace#GRAPHSETS}.
 * 
 * @author m.wauer
 * 
 */
@ApiModel(value = "Graph Set", description = "Graph Set resource representation")
@XStreamAlias("graphSet")
public class GraphSet implements RdfConvertible<GraphSet> {

    public static final URI GRAPHSET_TYPE = new URIImpl(Namespace.COEVOLUTION + "GraphSet");

    @ApiModelProperty(value = "the identifier GUID", required = true)
    private String identifier;

    @ApiModelProperty(value = "the extended description of a graph set")
    private String description;

    @ApiModelProperty(value = "the label of the graph set, typically the identifer")
    private String label;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = RdfUtils.DATE_FORMAT_PATTERN, timezone = "UTC")
    @ApiModelProperty(value = "the created timestamp, as xsd:dateTime. In serialized formats, the string value has to conform to: ISO8601 for turtle: yyyy-MM-dd'T'HH:mm:ssX, and a related simple date format for JSON: yyyy-MM-dd'T'HH:mm:ssZ - example: 2015-05-21T11:53:55+00:00", dataType = "dateTime", notes = "If not given, this value will be autogenerated when creating a new graphset.", required = false)
    private Date created;

    /**
     * Default constructor.
     */
    public GraphSet() {

    }

    /**
     * Constructor.
     * 
     * @param identifier
     *            a GUID identifier of the graph set
     */
    public GraphSet(String identifier) {
        this.identifier = identifier;
    }

    public String getIdentifier() {
        return identifier;
    }

    public void setIdentifier(String identifier) {
        this.identifier = identifier;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public Date getCreated() {
        return created;
    }

    public void setCreated(Date created) {
        this.created = created;
    }

    @Override
    public Model toModel() {
        LinkedHashModel model = new LinkedHashModel();
        URIImpl identifierURI = new URIImpl(Namespace.GRAPHSETS + identifier);
        model.add(identifierURI, RDF.TYPE, GRAPHSET_TYPE);
        if (getDescription() != null) {
            model.add(identifierURI, DCTERMS.DESCRIPTION, new LiteralImpl(getDescription()));
        }
        if (getLabel() != null) {
            model.add(identifierURI, RDFS.LABEL, new LiteralImpl(getLabel()));
        }
        if (getCreated() != null) {
            model.add(identifierURI, DCTERMS.CREATED, new LiteralImpl(
                    RdfUtils.formatIso8601Date(getCreated()), XMLSchema.DATETIME));
        }

        return model;
    }

    @Override
    public GraphSet fromModel(Model model, URI subject) {
        if (subject == null) {
            // try to identify subject
            Set<Resource> subjects = model.filter(null, RDF.TYPE, GRAPHSET_TYPE).subjects();
            if (subjects.size() == 1) {
                subject = (URI) subjects.iterator().next();
            }
            else {
                throw new SerializationException("No subject given, but subject can't be derived from model: "
                        + subjects.size() + " graphsets found in model");
            }
        }

        // extract required properties
        String description = model.filter(subject, DCTERMS.DESCRIPTION, null).objectString();
        String label = model.filter(subject, RDFS.LABEL, null).objectString();
        Value createdValue = model.filter(subject, DCTERMS.CREATED, null).objectValue();

        GraphSet graphSet = new GraphSet(
                StringUtils.substringAfter(subject.stringValue(), Namespace.GRAPHSETS));
        // add optional properties
        graphSet.setDescription(description);
        graphSet.setLabel(label);

        try {
            if (null != createdValue) {
                graphSet.setCreated(RdfUtils.parseIso8601Date(createdValue.stringValue()));
            }
        } catch (ParseException e) {
            throw new SerializationException("Invalid date: " + created, e);
        }

        return graphSet;
    }

}
